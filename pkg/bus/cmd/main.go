package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	projectRoot := "."
	contractDir := filepath.Join(projectRoot, "contract")
	outFile := filepath.Join(contractDir, "generated", "client.go")

	os.MkdirAll(filepath.Dir(outFile), 0755)

	files, err := os.ReadDir(contractDir)
	if err != nil {
		panic(err)
	}

	builder := strings.Builder{}
	builder.WriteString(`package client

import (
	"context"
	"go-bus/contract"
	"go-bus/pkg/bus"
)

// Code generated by busgen. DO NOT EDIT.

`)

	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".go") {
			continue
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, filepath.Join(contractDir, file.Name()), nil, parser.AllErrors)
		if err != nil {
			panic(err)
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if iface, ok := ts.Type.(*ast.InterfaceType); ok {
					interfaceName := ts.Name.Name // เช่น ExamContract
					prefix := strings.TrimSuffix(interfaceName, "Contract")

					for _, method := range iface.Methods.List {
						if len(method.Names) == 0 {
							continue
						}

						name := method.Names[0].Name
						fn := method.Type.(*ast.FuncType)

						var reqType, resType string

						// parameter ตัวที่สองคือ request
						if fn.Params != nil && len(fn.Params.List) > 1 {
							reqExpr := fn.Params.List[1].Type
							reqType = exprToString(reqExpr)
						} else {
							reqType = "any"
						}

						// return ตัวแรกคือ response
						if fn.Results != nil && len(fn.Results.List) > 0 {
							resExpr := fn.Results.List[0].Type
							resType = exprToString(resExpr)
						} else {
							resType = "any"
						}

						builder.WriteString(fmt.Sprintf(`
func %s%s(ctx context.Context, b *bus.RequestBus, req %s) (%s, error) {
	res, err := bus.CallContract[%s, %s](ctx, b, "%s.%s", req)
	if err != nil {
		var zero %s
		return zero, err
	}
	return res, nil
}
`, prefix, name,
							reqType, resType,
							reqType, resType,
							prefix, name,
							resType))
					}
				}
			}
		}
	}

	err = os.WriteFile(outFile, []byte(builder.String()), 0644)
	if err != nil {
		panic(err)
	}

	fmt.Println("✅ Generated:", outFile)
}

func exprToString(expr ast.Expr) string {
	switch v := expr.(type) {
	case *ast.Ident:
		return "contract." + v.Name
	case *ast.StarExpr:
		return "*" + exprToString(v.X)
	case *ast.SelectorExpr:
		return "contract." + v.Sel.Name
	default:
		return "any"
	}
}

// ต่อมาคือมันจะดีมากถ้าเรามีสักอย่างคล้ายๆ cli tools เพื่อ complie contract/exam.go contract/session.go ออกมาเป็น wrapper function func FindExamById(ID string) (*contract.ExamResponse, err) { examResult, err := l.bus.CallContract( ctx, "Exam.FindExamById", contract.ExamRequest{ID: session.ExamId}, ) exam := examResult.(*contract.ExamResponse) if err != nil { return nil, err } return exam, nil }
